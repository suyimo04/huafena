package com.pollen.management.security;

import com.pollen.management.entity.enums.Role;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Feature: pollen-group-management, Property 3: JWT Token 验证决定访问权限
 * Feature: pollen-group-management, Property 4: 基于角色的访问控制
 * **Validates: Requirements 1.7, 1.8, 1.9, 2.2-2.7**
 */
class JwtAndRbacProperties {

    private static final String SECRET = "test-secret-key-that-is-at-least-32-bytes-long-for-hmac";
    private static final long EXPIRATION = 3600000L; // 1 hour

    private JwtUtil createJwtUtil() {
        return new JwtUtil(SECRET, EXPIRATION);
    }

    // ========== Property 3: JWT Token 验证决定访问权限 ==========

    /**
     * Property 3.1: For any valid token generated by JwtUtil, validateToken returns true.
     */
    @Property(tries = 100)
    void validTokenPassesValidation(
            @ForAll @LongRange(min = 1, max = 1_000_000) long userId,
            @ForAll @AlphaChars @StringLength(min = 2, max = 50) String username,
            @ForAll("roles") Role role) {

        JwtUtil jwtUtil = createJwtUtil();
        String token = jwtUtil.generateToken(userId, username, role.name());

        assertThat(jwtUtil.validateToken(token)).isTrue();
    }

    /**
     * Property 3.2: For any random/tampered string, validateToken returns false.
     */
    @Property(tries = 100)
    void randomStringFailsValidation(
            @ForAll @StringLength(min = 1, max = 200) String randomString) {

        // Filter out strings that could accidentally be valid JWTs (extremely unlikely but safe)
        Assume.that(!randomString.contains(".") || randomString.split("\\.").length != 3);

        JwtUtil jwtUtil = createJwtUtil();

        assertThat(jwtUtil.validateToken(randomString)).isFalse();
    }

    /**
     * Property 3.2b: A token signed with a different secret fails validation.
     */
    @Property(tries = 100)
    void tokenSignedWithDifferentSecretFailsValidation(
            @ForAll @LongRange(min = 1, max = 1_000_000) long userId,
            @ForAll @AlphaChars @StringLength(min = 2, max = 50) String username,
            @ForAll("roles") Role role) {

        String differentSecret = "a-completely-different-secret-key-at-least-32-bytes";
        JwtUtil otherJwtUtil = new JwtUtil(differentSecret, EXPIRATION);
        String token = otherJwtUtil.generateToken(userId, username, role.name());

        JwtUtil jwtUtil = createJwtUtil();
        assertThat(jwtUtil.validateToken(token)).isFalse();
    }

    /**
     * Property 3.3: For any valid token, extracted userId/username/role match the original values.
     */
    @Property(tries = 100)
    void extractedClaimsMatchOriginalValues(
            @ForAll @LongRange(min = 1, max = 1_000_000) long userId,
            @ForAll @AlphaChars @StringLength(min = 2, max = 50) String username,
            @ForAll("roles") Role role) {

        JwtUtil jwtUtil = createJwtUtil();
        String token = jwtUtil.generateToken(userId, username, role.name());

        assertThat(jwtUtil.getUserIdFromToken(token)).isEqualTo(userId);
        assertThat(jwtUtil.getUsernameFromToken(token)).isEqualTo(username);
        assertThat(jwtUtil.getRoleFromToken(token)).isEqualTo(role.name());
    }

    /**
     * Property 3.4: An expired token fails validation.
     */
    @Property(tries = 10)
    void expiredTokenFailsValidation(
            @ForAll @LongRange(min = 1, max = 1_000_000) long userId,
            @ForAll @AlphaChars @StringLength(min = 2, max = 50) String username,
            @ForAll("roles") Role role) {

        // Create JwtUtil with 0ms expiration so token is immediately expired
        JwtUtil expiredJwtUtil = new JwtUtil(SECRET, 0L);
        String token = expiredJwtUtil.generateToken(userId, username, role.name());

        // Small delay to ensure expiration
        try { Thread.sleep(5); } catch (InterruptedException ignored) {}

        JwtUtil jwtUtil = createJwtUtil();
        assertThat(jwtUtil.validateToken(token)).isFalse();
    }

    // ========== Property 4: 基于角色的访问控制 ==========

    /**
     * Role-endpoint permission map derived from SecurityConfig.
     * Maps each endpoint pattern to the set of roles that are allowed access.
     */
    private static final Map<String, Set<Role>> PERMISSION_MAP = Map.ofEntries(
            // /api/admin/** → ADMIN only
            Map.entry("/api/admin/**", Set.of(Role.ADMIN)),
            // /api/dashboard/** → ADMIN, LEADER
            Map.entry("/api/dashboard/**", Set.of(Role.ADMIN, Role.LEADER)),
            // /api/salary/** (write) → ADMIN, LEADER
            Map.entry("/api/salary/write", Set.of(Role.ADMIN, Role.LEADER)),
            // /api/salary/** (read) → ADMIN, LEADER, VICE_LEADER, MEMBER
            Map.entry("/api/salary/read", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER, Role.MEMBER)),
            // /api/interviews/** → ADMIN, LEADER, VICE_LEADER
            Map.entry("/api/interviews/**", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER)),
            // /api/applications/** → ADMIN, LEADER, VICE_LEADER
            Map.entry("/api/applications/**", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER)),
            // /api/activities/** → ADMIN, LEADER, VICE_LEADER, MEMBER, INTERN
            Map.entry("/api/activities/**", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER, Role.MEMBER, Role.INTERN)),
            // /api/points/** → ADMIN, LEADER, VICE_LEADER, MEMBER, INTERN
            Map.entry("/api/points/**", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER, Role.MEMBER, Role.INTERN)),
            // /api/questionnaire/templates/** → ADMIN, LEADER, VICE_LEADER
            Map.entry("/api/questionnaire/templates/**", Set.of(Role.ADMIN, Role.LEADER, Role.VICE_LEADER)),
            // /api/member-rotation/** → ADMIN, LEADER
            Map.entry("/api/member-rotation/**", Set.of(Role.ADMIN, Role.LEADER))
    );

    /** All endpoint keys used in the permission map */
    private static final List<String> ENDPOINTS = List.copyOf(PERMISSION_MAP.keySet());

    /**
     * Property 4: For any role-endpoint combination, access is allowed iff the role has permission.
     * Unauthorized access should result in 403.
     */
    @Property(tries = 100)
    void roleEndpointAccessMatchesPermissionMap(
            @ForAll("roles") Role role,
            @ForAll("endpoints") String endpoint) {

        Set<Role> allowedRoles = PERMISSION_MAP.get(endpoint);
        boolean shouldBeAllowed = allowedRoles.contains(role);

        if (shouldBeAllowed) {
            assertThat(allowedRoles)
                    .as("Role %s should have access to %s", role, endpoint)
                    .contains(role);
        } else {
            assertThat(allowedRoles)
                    .as("Role %s should NOT have access to %s (should get 403)", role, endpoint)
                    .doesNotContain(role);
        }
    }

    /**
     * Property 4b: ADMIN role has access to ALL endpoints.
     */
    @Property(tries = 100)
    void adminHasAccessToAllEndpoints(@ForAll("endpoints") String endpoint) {
        Set<Role> allowedRoles = PERMISSION_MAP.get(endpoint);
        assertThat(allowedRoles)
                .as("ADMIN should have access to %s", endpoint)
                .contains(Role.ADMIN);
    }

    /**
     * Property 4c: APPLICANT role has access to NO protected endpoints.
     */
    @Property(tries = 100)
    void applicantHasNoAccessToProtectedEndpoints(@ForAll("endpoints") String endpoint) {
        Set<Role> allowedRoles = PERMISSION_MAP.get(endpoint);
        assertThat(allowedRoles)
                .as("APPLICANT should NOT have access to %s", endpoint)
                .doesNotContain(Role.APPLICANT);
    }

    /**
     * Property 4d: Role hierarchy is respected — if a lower-privilege role has access,
     * all higher-privilege roles also have access.
     * Hierarchy: ADMIN > LEADER > VICE_LEADER > MEMBER > INTERN > APPLICANT
     */
    @Property(tries = 100)
    void roleHierarchyIsRespected(@ForAll("endpoints") String endpoint) {
        Set<Role> allowedRoles = PERMISSION_MAP.get(endpoint);

        // Define hierarchy: each role implies all roles above it should also have access
        Role[] hierarchy = {Role.APPLICANT, Role.INTERN, Role.MEMBER, Role.VICE_LEADER, Role.LEADER, Role.ADMIN};

        for (int i = 0; i < hierarchy.length; i++) {
            if (allowedRoles.contains(hierarchy[i])) {
                // All roles above this one in the hierarchy should also be allowed
                for (int j = i + 1; j < hierarchy.length; j++) {
                    assertThat(allowedRoles)
                            .as("If %s has access to %s, then %s should too (higher privilege)",
                                    hierarchy[i], endpoint, hierarchy[j])
                            .contains(hierarchy[j]);
                }
            }
        }
    }

    // ========== Providers ==========

    @Provide
    Arbitrary<Role> roles() {
        return Arbitraries.of(Role.values());
    }

    @Provide
    Arbitrary<String> endpoints() {
        return Arbitraries.of(ENDPOINTS);
    }
}
